<#@ template language="C#" #>
<#@ output extension=".cs" #>
// <auto-generated />
using Macaron.DependencyInjection.Internal;

namespace Macaron.DependencyInjection;

public static partial class IDependencyRegistrarExtensions
{
    public static void Register<T>(
        this IDependencyRegistrar dependencyRegistrar,
        Key<T> key,
        Func<IDependencyContainer, T> factory,
        LifeTime lifeTime
    ) where T : notnull
    {
        var (type, tag) = key;
        switch (lifeTime)
        {
            case LifeTime.Transient:
                dependencyRegistrar.RegisterTransient(
                    type,
                    tag,
                    factory: dependencyContainer => factory.Invoke(dependencyContainer)
                );
                break;
            case LifeTime.Scoped:
                dependencyRegistrar.RegisterScoped(
                    type,
                    tag,
                    factory: dependencyContainer => factory.Invoke(dependencyContainer)
                );
                break;
            case LifeTime.Singleton:
                dependencyRegistrar.RegisterSingleton(
                    type,
                    tag,
                    factory: dependencyContainer => factory.Invoke(dependencyContainer),
                    externallyOwned: false
                );
                break;
            default:
                throw new InvalidOperationException($"Not supported life time: {lifeTime}");
        }
    }

    public static void Register<T>(
        this IDependencyRegistrar dependencyRegistrar,
        Key<T> key,
        Func<T> factory,
        LifeTime lifeTime
    ) where T : notnull
    {
        Register(dependencyRegistrar, key, factory: _ => factory.Invoke(), lifeTime);
    }

    public static void Register<T>(
        this IDependencyRegistrar dependencyRegistrar,
        Func<IDependencyContainer, T> factory,
        LifeTime lifeTime
    ) where T : notnull
    {
        Register(dependencyRegistrar, key: Key.Of<T>(), factory, lifeTime);
    }

    public static void Register<T>(
        this IDependencyRegistrar dependencyRegistrar,
        Func<T> factory,
        LifeTime lifeTime
    ) where T : notnull
    {
        Register(dependencyRegistrar, key: Key.Of<T>(), factory: _ => factory.Invoke(), lifeTime);
    }

    public static void Register<T>(
        this IDependencyRegistrar dependencyRegistrar,
        Key<T> key,
        LifeTime lifeTime
    ) where T : notnull, new()
    {
        Register(dependencyRegistrar, key, factory: _ => new T(), lifeTime);
    }

    public static void Register<TInterface, TImplementation>(
        this IDependencyRegistrar dependencyRegistrar,
        Key<TInterface> key,
        LifeTime lifeTime
    )
        where TInterface : notnull
        where TImplementation : TInterface, new()
    {
        Register(dependencyRegistrar, key, factory: _ => new TImplementation(), lifeTime);
    }

    public static void Register<T>(
        this IDependencyRegistrar dependencyRegistrar,
        LifeTime lifeTime
    ) where T : notnull, new()
    {
        Register(dependencyRegistrar, key: Key.Of<T>(), factory: _ => new T(), lifeTime);
    }

    public static void Register<TInterface, TImplementation>(
        this IDependencyRegistrar dependencyRegistrar,
        LifeTime lifeTime
    )
        where TInterface : notnull
        where TImplementation : TInterface, new()
    {
        Register(dependencyRegistrar, key: Key.Of<TInterface>(), factory: _ => new TImplementation(), lifeTime);
    }

<#
foreach (var scope in new[] { "Transient", "Scoped", "Singleton" })
{
#>
    #region <#= scope #>
    public static void Register<#= scope #><T>(
        this IDependencyRegistrar dependencyRegistrar,
        Key<T> key,
        Func<IDependencyContainer, T> factory
    ) where T : notnull
    {
        Register(dependencyRegistrar, key, factory, lifeTime: LifeTime.<#= scope #>);
    }

    public static void Register<#= scope #><T>(
        this IDependencyRegistrar dependencyRegistrar,
        Key<T> key,
        Func<T> factory
    ) where T : notnull
    {
        Register(dependencyRegistrar, key, factory: _ => factory.Invoke(), lifeTime: LifeTime.<#= scope #>);
    }

    public static void Register<#= scope #><T>(
        this IDependencyRegistrar dependencyRegistrar,
        Func<IDependencyContainer, T> factory
    ) where T : notnull
    {
        Register(dependencyRegistrar, key: Key.Of<T>(), factory, lifeTime: LifeTime.<#= scope #>);
    }

    public static void Register<#= scope #><T>(
        this IDependencyRegistrar dependencyRegistrar,
        Func<T> factory
    ) where T : notnull
    {
        Register(dependencyRegistrar, key: Key.Of<T>(), factory: _ => factory.Invoke(), lifeTime: LifeTime.<#= scope #>);
    }

    public static void Register<#= scope #><T>(
        this IDependencyRegistrar dependencyRegistrar,
        Key<T> key
    ) where T : notnull, new()
    {
        Register(dependencyRegistrar, key, factory: _ => new T(), lifeTime: LifeTime.<#= scope #>);
    }

    public static void Register<#= scope #><TInterface, TImplementation>(
        this IDependencyRegistrar dependencyRegistrar,
        Key<TInterface> key
    )
        where TInterface : notnull
        where TImplementation : TInterface, new()
    {
        Register(dependencyRegistrar, key, factory: _ => new TImplementation(), lifeTime: LifeTime.<#= scope #>);
    }

    public static void Register<#= scope #><T>(
        this IDependencyRegistrar dependencyRegistrar
    ) where T : notnull, new()
    {
        Register(dependencyRegistrar, key: Key.Of<T>(), factory: _ => new T(), lifeTime: LifeTime.<#= scope #>);
    }

    public static void Register<#= scope #><TInterface, TImplementation>(
        this IDependencyRegistrar dependencyRegistrar
    )
        where TInterface : notnull
        where TImplementation : TInterface, new()
    {
        Register(dependencyRegistrar, key: Key.Of<TInterface>(), factory: _ => new TImplementation(), lifeTime: LifeTime.<#= scope #>);
    }
    #endregion

<#
}
#>
    #region Instance
    public static void RegisterSingleton<T>(
        this IDependencyRegistrar dependencyRegistrar,
        Key<T> key,
        T instance,
        bool externallyOwned = false
    ) where T : notnull
    {
        dependencyRegistrar.RegisterSingleton(key.Type, key.Tag, factory: _ => instance, externallyOwned);
    }

    public static void RegisterSingleton<T>(
        this IDependencyRegistrar dependencyRegistrar,
        T instance,
        bool externallyOwned = false
    ) where T : notnull
    {
        RegisterSingleton(dependencyRegistrar, key: Key.Of<T>(), instance, externallyOwned);
    }
    #endregion
}
